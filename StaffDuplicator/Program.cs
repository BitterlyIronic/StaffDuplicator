using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.WPF.Reflection.Attributes;
using System.Runtime;
using Mutagen.Bethesda.Plugins;
using System.Text.RegularExpressions;
using Noggog;
using Mutagen.Bethesda.Plugins.Cache;
using DynamicData;

namespace StaffDuplicator
{
    public class Settings
    {
        [SettingName("Mods to patch")]
        [Tooltip("List of mod filename (including extension) to source staves from")]
        public List<string> ModsToPatch = new();
        [SettingName("Patch Leveled Lists")]
        [Tooltip("If set, the patcher will update the vanilla leveled lists to point at the new staves")]
        public bool PatchLists = true;
        [SettingName("Hide Recipes")]
        [Tooltip("If set, the patcher will add a condition to generated recipes to hide them if the appropriate base staff isn't in the player's inventory")]
        public bool HideRecipes = false;
        [SettingName("Base Staves")]
        [Tooltip("A list of editor ids for base, unenchanted staves to generate duplicates for")]
        public List<string> BaseStaves = new() { "ccBGSSSE066_StaffTemplateDreugh",
                                                 "ccBGSSSE066_StaffTemplateEbony",
                                                 "ccBGSSSE066_StaffTemplateDaedric",
                                                 "ccBGSSSE066_StaffTemplateGlass",
                                                 "ccBGSSSE066_StaffTemplateSilver",
                                                 "ccBGSSSE066_StaffTemplateSteel",
                                                 "ccBGSSSE066_StaffTemplateWood",
                                                 "ccBGSSSE066_StaffTemplateWood02" };
        [SettingName("Name Regex")]
        [Tooltip("The regex used to get the staff prefixes, don't mess with this unless you know what you're doing")]
        public string StaffRegex = @"Unenchanted (\w+) Staff";
    }

    public class BaseStaff
    {
        public string? EditorId;
        public string? Prefix;
        public string? Suffix;
        public float Weight;
        public FormKey FormKey;
        internal IFormLinkNullableGetter<IStaticGetter>? FirstModel;
        internal IModelGetter Model = new Model();
        internal IObjectBoundsGetter Bounds = new ObjectBounds();
    }

    public class Program
    {
        private static Lazy<Settings>? settings;

        private static readonly ModKey Mysticism = ModKey.FromNameAndExtension("MysticismMagic.esp");

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("settings", "settings.json", out settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "StaffDuplicates.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var hasMysticism = state.LoadOrder.ContainsKey(Mysticism);

            var staffKeyword = state.LinkCache.Resolve<IKeywordGetter>("WeapTypeStaff").ToNullableLink();
            var modsToPatch = (settings?.Value.ModsToPatch ?? throw new ArgumentException("Settings failed to load")).Select(x => ModKey.FromNameAndExtension(x)).ToList();
            var baseStaves = BuildBaseStaffList(state, settings?.Value.BaseStaves ?? throw new ArgumentException("Settings failed to load"));
            Dictionary<Skill, IFormLinkNullable<IKeywordGetter>> keywordDict = new();

            if (hasMysticism)
            {
                // inject the mysticism staff keywords
                keywordDict.Add(Skill.Alteration, state.PatchMod.Keywords.GetOrAddAsOverride(state.LinkCache.Resolve<IKeywordGetter>("MAG_StaffTypeAlteration")).ToNullableLink());
                keywordDict.Add(Skill.Conjuration, state.PatchMod.Keywords.GetOrAddAsOverride(state.LinkCache.Resolve<IKeywordGetter>("MAG_StaffTypeConjuration")).ToNullableLink());
                keywordDict.Add(Skill.Destruction, state.PatchMod.Keywords.GetOrAddAsOverride(state.LinkCache.Resolve<IKeywordGetter>("MAG_StaffTypeDestruction")).ToNullableLink());
                keywordDict.Add(Skill.Illusion, state.PatchMod.Keywords.GetOrAddAsOverride(state.LinkCache.Resolve<IKeywordGetter>("MAG_StaffTypeIllusion")).ToNullableLink());
                keywordDict.Add(Skill.Restoration, state.PatchMod.Keywords.GetOrAddAsOverride(state.LinkCache.Resolve<IKeywordGetter>("MAG_StaffTypeRestoration")).ToNullableLink());
            }

            state.LoadOrder.AssertListsMods(modsToPatch);

            List<FormKey> stavesToPatch = new();

            foreach (var mod in modsToPatch)
            {
                // staves that have editor ids and templates
                stavesToPatch.AddRange(state.LoadOrder.TryGetValue(mod)!.Mod!.Weapons.Where(x => x.EditorID != null
                        && x.HasKeyword(staffKeyword)).Select(x => x.FormKey));
            }

            stavesToPatch = stavesToPatch.Distinct().ToList();

            var cObjects = state.LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides().ToList();
            var staves = state.LoadOrder.PriorityOrder.Weapon().WinningContextOverrides().Where(x => !x.Record.Template.IsNull
                && stavesToPatch.Contains(x.Record.FormKey)
                && cObjects.Any(y => y.CreatedObject.FormKey == x.Record.FormKey)).ToList();
            Console.WriteLine("Starting");

            foreach (var staff in staves)
            {
                var record = staff.Record;
                Console.WriteLine($"Processing: {record.Name} from {staff.ModKey.Name}");

                var recipes = cObjects.Where(x => x.CreatedObject.FormKey == record.FormKey).ToList();
                LeveledItem? lList = null;
                if (settings.Value.PatchLists)
                {
                    lList = state.PatchMod.LeveledItems.AddNew();

                    lList.EditorID = $"{record.EditorID}Sublist";
                    lList.Entries ??= new();
                }

                foreach (var baseStaff in baseStaves)
                {
                    var newStaff = state.PatchMod.Weapons.DuplicateInAsNewRecord(record);
                    newStaff.BasicStats ??= new();

                    newStaff.EditorID += baseStaff.Suffix;
                    newStaff.BasicStats.Weight = baseStaff.Weight;
                    newStaff.Model = baseStaff.Model.DeepCopy();
                    newStaff.FirstPersonModel = baseStaff.FirstModel?.AsSetter().AsNullable() ?? throw new Exception("The model is gone???");
                    newStaff.ObjectBounds = baseStaff.Bounds.DeepCopy();
                    newStaff.Name = $"{baseStaff.Prefix} {record.Name}";
                    newStaff.Template.SetToNull();

                    if (keywordDict.TryGetValue(record.Data?.Skill ?? throw new Exception("No data somehow?"), out var keyword))
                    {
                        newStaff.Keywords ??= new();
                        newStaff.Keywords.Add(keyword);
                    }

                    // copy all recipes pointing at the original staff and make duplicates
                    foreach (var recipe in recipes)
                    {
                        var newRecipe = state.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(recipe);
                        newRecipe.EditorID += baseStaff.Suffix;
                        newRecipe.CreatedObject.FormKey = newStaff.FormKey;
                        newRecipe.Items?.Where(x => x.Item.Item.FormKey == record.Template.FormKey).ForEach(x => x.Item.Item.FormKey = baseStaff.FormKey);

                        if (settings.Value.HideRecipes)
                        {
                            var condData = new GetItemCountConditionData
                            {
                                RunOnType = Condition.RunOnType.Reference,
                                Reference = FormKey.Factory("000014:Skyrim.esm").ToLink<ISkyrimMajorRecordGetter>()
                            };

                            var cond = new ConditionFloat
                            {
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                ComparisonValue = 1f,
                                Data = condData
                            };

                            condData.ItemOrList.Link.SetTo(baseStaff.FormKey);

                            newRecipe.Conditions.Add(cond);
                        }
                    }

                    // build up a sublist containing the variant staves
                    lList?.Entries?.Add(new LeveledItemEntry
                    {
                        Data = new LeveledItemEntryData
                        {
                            Count = 1,
                            Level = 1,
                            Reference = newStaff.ToLink()
                        }
                    });
                }

                // loop over every leveled list that includes the original staff and update it to point at the sublist
                if (settings.Value.PatchLists)
                    Parallel.ForEach(state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides(), x =>
                    {
                        if (x.Entries?.Any(y => y.Data?.Reference.FormKey == record.FormKey) ?? false)
                        {
                            lock (state)
                            {
                                var newList = state.PatchMod.LeveledItems.GetOrAddAsOverride(x);

                                newList.Entries ??= new();
                                foreach (var entry in newList.Entries)
                                {
                                    entry.Data ??= new();
                                    if (entry.Data.Reference.FormKey == record.FormKey)
                                        entry.Data.Reference.FormKey = lList!.FormKey;
                                }
                            }
                        }
                    });

                // do this here so the above won't nab it and make the list recursive
                lList?.Entries?.Add(new LeveledItemEntry
                {
                    Data = new LeveledItemEntryData
                    {
                        Count = 1,
                        Level = 1,
                        Reference = record.ToNullableLink()
                    }
                });
            }
        }

        private static IList<BaseStaff> BuildBaseStaffList(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IEnumerable<string> eIds)
        {
            var list = new List<BaseStaff>();
            var prefixRegex = new Regex(settings!.Value.StaffRegex, RegexOptions.Compiled | RegexOptions.IgnoreCase);
            var suffixCheck = new HashSet<string>();

            foreach (var e in eIds)
            {
                var staff = state.LinkCache.Resolve<IWeaponGetter>(e);

                var baseStaff = new BaseStaff
                {
                    EditorId = e,
                    FirstModel = staff.FirstPersonModel,
                    Model = staff.Model ?? throw new Exception("The base staves you pick should probably all have models"),
                    Weight = staff.BasicStats?.Weight ?? 8f,
                    Bounds = staff.ObjectBounds,
                    FormKey = staff.FormKey
                };

                var origName = staff.Name?.ToString() ?? string.Empty;

                var match = prefixRegex.Match(origName);
                baseStaff.Prefix = match.Groups[1].Value;
                baseStaff.Suffix = baseStaff.Prefix;

                int count = 2;

                while (suffixCheck.Contains(baseStaff.Suffix))
                    baseStaff.Suffix = $"{baseStaff.Prefix}{count++}";

                suffixCheck.Add(baseStaff.Suffix);

                list.Add(baseStaff);
            }

            return list;
        }
    }
}
